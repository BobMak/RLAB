package com.cratus.db;

import org.junit.Assert;
import org.junit.Test;

import java.io.*;
import java.lang.reflect.Array;
import java.util.*;
import java.util.Map;

import static org.junit.Assert.*;

import com.cliffc.util.AryInt;

public class TestModel {
  private class DataPoint{
    AryInt gw_xys;   // pairs of gateway xs and ys
    AryInt rssis;  // xys and rssis mapping: rssis[i] -> gw_xys.slice( 2*x , 2*x+2 )
    short true_x, true_y;
    DataPoint(AryInt rssis, AryInt gw_xys, short true_x, short true_y) {
      this.gw_xys = gw_xys;
      this.rssis = rssis;
      this.true_x = true_x;
      this.true_y = true_y;
    }
    public AryInt get_in() { return this.rssis; }
    public int[] get_out() { return new int[] {this.true_x, this.true_y} ;}
    public String toString() {
      String x = String.valueOf(this.true_x);
      String y = String.valueOf(this.true_y);
      String out = String.valueOf(this.rssis);
      return String.join(" | ", new String[] {x, y, out} ); }
    }
  // Test of the location algorithm against manually entered real sensor and gateway locations
  @Test
  public void baseline() {
    try {
      DB.main(new String[]{"-port","2345","-path","src/test/data/test2","-nobackup"});

      // Combine true locations and rssi's in one data set
      DataPoint[] all_points = new DataPoint[10];
      int p_idx = 0;
      for ( Map.Entry<String, Sensor>  s: Cratus.CRATUS._sensors.entrySet() ) {
        String sens_name = s.getKey();
        Sensor sens = s.getValue();
        // Iterate through every sensor Real Location record
        File dir = new File("src/test/data/test2/sensors");
        File[] directoryListing = dir.listFiles();
        if (directoryListing != null) {
          for (File record : directoryListing) {
            if ( record.getName().startsWith("RLOC") ) {
              try( BufferedReader br = new BufferedReader(new FileReader(record)) ) {
                br.readLine();  // skip annotations
                // Record all gateways that were available during the recording and
                String[] start_stop_x_y = br.readLine().split(",");
                long time_start = Long.parseLong(start_stop_x_y[0]);
                long time_stop  = Long.parseLong(start_stop_x_y[1]);
                short true_x    =Short.parseShort(start_stop_x_y[2]);
                short true_y    =Short.parseShort(start_stop_x_y[3]);
                HashMap<Integer,int[]> gw_pos = new HashMap<>();
                String gw_row = "";
                int x_buff;
                int y_buff;
                while ( (gw_row = br.readLine()) != null ) {
                  x_buff = Integer.parseInt(gw_row.split(",")[1]);
                  y_buff = Integer.parseInt(gw_row.split(",")[2]);
                  gw_pos.put ( Integer.parseInt(gw_row.split(",")[0]), new int[] {x_buff, y_buff} );
                }
                // Get all rssi values from that time interval
                int idx_start = sens.binary_search(time_start);
                int idx_stop  = sens.binary_search(time_stop);
                long current_time = 0;
                AryInt rssis  = new AryInt();
                AryInt gw_xys = new AryInt();
                for ( int i=idx_start; i<idx_stop; i++ ) {
                  rssis.push( sens._rssis[i] );
                  gw_xys.push( gw_pos.get( sens._gates[i] )[0] );
                  gw_xys.push( gw_pos.get( sens._gates[i] )[1] );
                  if (current_time!=sens._times[i]) {
                    current_time = sens._times[i];
                    DataPoint p = new DataPoint( rssis, gw_xys, true_x, true_y );
                    all_points[p_idx] = (p);
                    p_idx++;
                    if (all_points.length == p_idx) {
                      all_points = Arrays.copyOf( all_points, all_points.length<<1 );
                    }
                    rssis  = new AryInt();
                    gw_xys = new AryInt();
                  }
                }
                all_points = Arrays.copyOf( all_points, p_idx );
                for ( DataPoint d: all_points ) {
                  System.out.println(d.toString());
                }
              } catch( IOException ioe ) {
                System.err.println("Failed to open "+record.getName()+" due to: "+ioe);
              }
            }
          }
        } else {
          System.out.println("Not a directory");
        }
      }
      Assert.assertTrue( all_points.length > 0 );
    } finally {
      DB.stop();
    }
//    Double[] x = new Double[7];
//    x[0] = 0.038;
//    x[1] = 0.194;
//    x[2] = 0.425;
//    x[3] = 0.626;
//    x[4] = 1.253;
//    x[5] = 2.500;
//    x[6] = 3.740;
//    double[] y = new double[] { 0.050, 0.127, 0.094, 0.2122, 0.2729, 0.2665, 0.3317 };
//    GaussNewton<Double> gaussNewton = new GaussNewton<Double>() {
//      // Find b[0],b[1] such that errors on Y are minimized.
//      @Override public double findY(Double x, double[] b) {  return (x * b[0]) / (b[1] + x);  }
//    };
//    double[] b_guess = new double[]{1,1};
//    double[] b = gaussNewton.optimise(x, y, b_guess,1e-3,1e-6,1e-3,1000,false);
//    Assert.assertArrayEquals(new double[]{0.36, 0.56}, b, 0.01);
  }

}
